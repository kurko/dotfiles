#!/bin/bash

# backup-photos - Sync photography files to external SSDs
#
# DESCRIPTION:
#   Syncs ~/Pictures/Photography/ to external SSDs matching "Alex 2Tb *".
#   Handles partial syncs from multiple laptops with accumulative backups
#   (never deletes files from backup).
#
# USAGE:
#   backup-photos [OPTIONS]
#
# OPTIONS:
#   --dry-run, -n     Show what would be copied without copying
#   --verbose, -v     List each file as it's processed
#   --help, -h        Show usage information
#
# FILE TYPE BEHAVIOR:
#   Raw files (DNG, RAF, etc.)  - Skip if exists (immutable)
#   Image files (JPG, JPEG)     - Skip if exists (immutable)
#   Video files (MOV, MP4, etc) - Skip if exists (immutable)
#   Sidecar files (XMP, PP3, DOP) - Update if source is newer (mutable)
#   README.md                   - Update if source is newer (mutable)
#
# SPECIAL HANDLING:
#   - JPG files are skipped if a matching raw file exists in the same directory
#   - Exports folder: files with name collision but different size go to _collisions/
#
# DESTINATION:
#   /Volumes/Alex 2Tb */Photography/
#   Syncs to all matching drives that are currently mounted.

# =============================================================================
# Configuration
# =============================================================================

SOURCE_DIR="$HOME/Pictures/Photography"
DEST_PATTERN="Alex 2Tb *"
DEST_SUBDIR="Photography"
LOG_DIR="$HOME/.local/log"
LOG_FILE="$LOG_DIR/backup-photos.log"

# File extensions (case-insensitive matching)
RAW_EXTENSIONS="dng raf cr3 cr2 arw nef orf rw2"
VIDEO_EXTENSIONS="mov mp4 m4v"
SIDECAR_EXTENSIONS="xmp pp3 dop"
IMAGE_EXTENSIONS="jpg jpeg"

# =============================================================================
# Color codes
# =============================================================================

RED='\033[91m'
YELLOW='\033[93m'
GREEN='\033[92m'
BLUE='\033[94m'
CYAN='\033[96m'
BOLD='\033[1m'
NC='\033[0m'  # No Color

# =============================================================================
# Global variables
# =============================================================================

DRY_RUN=false
VERBOSE=false
VERSION="1.0"

# Counters
COUNT_COPIED=0
COUNT_SKIPPED_EXISTS=0
COUNT_SKIPPED_JPG_DNG=0
COUNT_SIDECARS_UPDATED=0
COUNT_COLLISIONS=0

# Temp files (cleaned up on exit)
TEMP_DIR=""
JPG_EXCLUDE_FILE=""

# =============================================================================
# Helper functions
# =============================================================================

log() {
    local msg="$1"
    echo -e "$msg"
    echo -e "$msg" | sed 's/\x1b\[[0-9;]*m//g' >> "$LOG_FILE"
}

log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        log "$1"
    fi
}

dry_run_prefix() {
    if [[ "$DRY_RUN" == true ]]; then
        echo "[DRY RUN] "
    fi
}

show_help() {
    cat << EOF
backup-photos v${VERSION}

Sync photography files to external SSDs matching "Alex 2Tb *"

USAGE:
    backup-photos [OPTIONS]

OPTIONS:
    -n, --dry-run     Show what would be copied without copying
    -v, --verbose     List each file as it's processed
    -h, --help        Show this help message

EXAMPLES:
    backup-photos                    # Sync to all matching drives
    backup-photos --dry-run          # Preview what would happen
    backup-photos --verbose          # Show each file during copy
    backup-photos -n -v              # Verbose dry run
EOF
}

cleanup() {
    if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
}

trap cleanup EXIT

# =============================================================================
# Argument parsing
# =============================================================================

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

# =============================================================================
# Drive detection
# =============================================================================

find_matching_drives() {
    # List actual mounted volumes and filter by pattern
    # Output one drive path per line for safe handling of spaces
    while IFS= read -r vol_name; do
        if [[ "$vol_name" == Alex\ 2Tb\ * ]]; then
            echo "/Volumes/$vol_name"
        fi
    done < <(ls /Volumes/ 2>/dev/null)
}

# Convert extension to case-insensitive pattern for rsync (e.g., "dng" -> "[Dd][Nn][Gg]")
ext_to_pattern() {
    local ext="$1"
    local pattern=""
    for (( i=0; i<${#ext}; i++ )); do
        local c="${ext:$i:1}"
        local upper=$(echo "$c" | tr '[:lower:]' '[:upper:]')
        local lower=$(echo "$c" | tr '[:upper:]' '[:lower:]')
        if [[ "$upper" != "$lower" ]]; then
            pattern+="[$upper$lower]"
        else
            pattern+="$c"
        fi
    done
    echo "$pattern"
}

# =============================================================================
# JPG deduplication
# =============================================================================

build_jpg_exclude_list() {
    local exclude_file="$1"

    # Find all JPG files and check if a matching raw exists
    find "$SOURCE_DIR" -type f \( -iname "*.jpg" -o -iname "*.jpeg" \) | while read -r jpg_file; do
        local dir=$(dirname "$jpg_file")
        local base=$(basename "$jpg_file")
        local name_without_ext="${base%.*}"

        # Skip files in Exports folder (no dedup there)
        if [[ "$dir" == *"/Exports"* ]]; then
            continue
        fi

        # Check if any raw file exists with same base name (case-insensitive)
        local has_raw=false
        for ext in $RAW_EXTENSIONS; do
            # Check both lowercase and uppercase versions
            local ext_upper=$(echo "$ext" | tr '[:lower:]' '[:upper:]')
            if [[ -f "$dir/$name_without_ext.$ext" ]] || [[ -f "$dir/$name_without_ext.$ext_upper" ]]; then
                has_raw=true
                break
            fi
        done

        if [[ "$has_raw" == true ]]; then
            # Get relative path from SOURCE_DIR
            local rel_path="${jpg_file#$SOURCE_DIR/}"
            echo "$rel_path" >> "$exclude_file"
        fi
    done
}

# =============================================================================
# Sync functions
# =============================================================================

sync_to_drive() {
    local dest_base="$1"
    local dest_dir="$dest_base/$DEST_SUBDIR"

    log ""
    log "$(dry_run_prefix)Syncing to: ${BOLD}$(basename "$dest_base")${NC}"

    # Create destination if it doesn't exist
    if [[ "$DRY_RUN" == false ]]; then
        mkdir -p "$dest_dir"
    fi

    # Sync year folders
    sync_year_folders "$dest_dir"

    # Sync Exports folder
    sync_exports_folder "$dest_dir"

    # Sync root README.md
    sync_readme "$SOURCE_DIR/README.md" "$dest_dir/README.md" "README.md"
}

sync_year_folders() {
    local dest_dir="$1"

    # Build rsync include patterns for extensions (case-insensitive)
    local raw_includes=()
    for ext in $RAW_EXTENSIONS; do
        raw_includes+=(--include="*.$(ext_to_pattern "$ext")")
    done

    local video_includes=()
    for ext in $VIDEO_EXTENSIONS; do
        video_includes+=(--include="*.$(ext_to_pattern "$ext")")
    done

    local image_includes=()
    for ext in $IMAGE_EXTENSIONS; do
        image_includes+=(--include="*.$(ext_to_pattern "$ext")")
    done

    local sidecar_includes=()
    for ext in $SIDECAR_EXTENSIONS; do
        sidecar_includes+=(--include="*.$(ext_to_pattern "$ext")")
    done

    # Base rsync options
    local rsync_base=(
        --archive
        --no-perms
        --exclude='.DS_Store'
        --exclude='._*'
        --exclude='.Trash*'
        --exclude='.*'
        --exclude='Exports'
        --exclude='_collisions'
    )

    if [[ "$VERBOSE" == true ]]; then
        rsync_base+=(--verbose)
    fi

    if [[ "$DRY_RUN" == true ]]; then
        rsync_base+=(--dry-run)
    fi

    # Phase 1: Sync mutable files (sidecars + README.md) with --update
    log_verbose "  Phase 1: Syncing sidecars and README files..."
    rsync "${rsync_base[@]}" \
        --update \
        "${sidecar_includes[@]}" \
        --include='README.md' \
        --include='*/' \
        --exclude='*' \
        "$SOURCE_DIR/" "$dest_dir/" 2>/dev/null

    # Phase 2: Sync immutable files with --ignore-existing
    log_verbose "  Phase 2: Syncing raw, image, and video files..."
    rsync "${rsync_base[@]}" \
        --ignore-existing \
        --exclude-from="$JPG_EXCLUDE_FILE" \
        "${raw_includes[@]}" \
        "${video_includes[@]}" \
        "${image_includes[@]}" \
        --include='*/' \
        --exclude='*' \
        "$SOURCE_DIR/" "$dest_dir/" 2>/dev/null
}

sync_exports_folder() {
    local dest_dir="$1"
    local exports_src="$SOURCE_DIR/Exports"
    local exports_dest="$dest_dir/Exports"

    if [[ ! -d "$exports_src" ]]; then
        return
    fi

    log_verbose "  Syncing Exports folder..."

    # Create Exports dir if needed
    if [[ "$DRY_RUN" == false ]]; then
        mkdir -p "$exports_dest"
    fi

    # Process each file in Exports (use process substitution to avoid subshell)
    while IFS= read -r src_file; do
        local rel_path="${src_file#$exports_src/}"
        local dest_file="$exports_dest/$rel_path"

        if [[ -f "$dest_file" ]]; then
            # File exists - check size
            local src_size=$(stat -f%z "$src_file" 2>/dev/null)
            local dest_size=$(stat -f%z "$dest_file" 2>/dev/null)

            if [[ "$src_size" == "$dest_size" ]]; then
                # Same size - skip
                log_verbose "  Skip: Exports/$rel_path (exists, same size)"
                ((COUNT_SKIPPED_EXISTS++))
            else
                # Different size - collision
                local file_date=$(stat -f%Sm -t%Y-%m "$src_file" 2>/dev/null)
                local collision_dir="$dest_dir/_collisions/$file_date"
                local collision_file="$collision_dir/$(basename "$src_file")"

                log "  ${YELLOW}Collision${NC}: Exports/$rel_path -> _collisions/$file_date/$(basename "$src_file")"

                if [[ "$DRY_RUN" == false ]]; then
                    mkdir -p "$collision_dir"
                    cp -p "$src_file" "$collision_file"
                fi
                ((COUNT_COLLISIONS++))
            fi
        else
            # File doesn't exist - copy
            log "  Copy: Exports/$rel_path"
            if [[ "$DRY_RUN" == false ]]; then
                mkdir -p "$(dirname "$dest_file")"
                cp -p "$src_file" "$dest_file"
            fi
            ((COUNT_COPIED++))
        fi
    done < <(find "$exports_src" -type f ! -name '.*' ! -name '._*')
}

sync_readme() {
    local src="$1"
    local dest="$2"
    local rel_path="$3"  # For display purposes

    if [[ ! -f "$src" ]]; then
        return
    fi

    if [[ -f "$dest" ]]; then
        # Check if source is newer
        if [[ "$src" -nt "$dest" ]]; then
            log "  Update: $rel_path (source newer)"
            if [[ "$DRY_RUN" == false ]]; then
                cp -p "$src" "$dest"
            fi
            ((COUNT_SIDECARS_UPDATED++))
        else
            log_verbose "  Skip: $rel_path (destination newer or same)"
            ((COUNT_SKIPPED_EXISTS++))
        fi
    else
        log "  Copy: $rel_path"
        if [[ "$DRY_RUN" == false ]]; then
            cp -p "$src" "$dest"
        fi
        ((COUNT_COPIED++))
    fi
}

# =============================================================================
# Main
# =============================================================================

main() {
    parse_args "$@"

    # Setup logging
    mkdir -p "$LOG_DIR"
    echo "" >> "$LOG_FILE"
    echo "========================================" >> "$LOG_FILE"
    echo "$(date): backup-photos started" >> "$LOG_FILE"

    # Header
    log ""
    log "${BOLD}backup-photos v${VERSION}${NC}"
    log "=================="

    if [[ "$DRY_RUN" == true ]]; then
        log "${YELLOW}[DRY RUN MODE]${NC}"
    fi

    # Check source exists
    if [[ ! -d "$SOURCE_DIR" ]]; then
        log "${RED}Error: Source directory not found: $SOURCE_DIR${NC}"
        exit 1
    fi

    # Find matching drives
    log ""
    log "Checking for drives matching \"${DEST_PATTERN}\"..."

    local drives=()
    while IFS= read -r drive; do
        [[ -n "$drive" ]] && drives+=("$drive")
    done < <(find_matching_drives)

    if [[ ${#drives[@]} -eq 0 ]]; then
        log "  ${RED}No matching drives found${NC}"
        log ""
        log "Mount an external drive named \"Alex 2Tb One\", \"Alex 2Tb Two\", etc."
        exit 1
    fi

    for drive in "${drives[@]}"; do
        log "  ${GREEN}âœ“${NC} $(basename "$drive") (mounted)"
    done

    # Setup temp files
    TEMP_DIR=$(mktemp -d)
    JPG_EXCLUDE_FILE="$TEMP_DIR/jpg_excludes.txt"
    touch "$JPG_EXCLUDE_FILE"

    # Build JPG exclusion list
    log ""
    log "Analyzing $SOURCE_DIR..."
    build_jpg_exclude_list "$JPG_EXCLUDE_FILE"

    local jpg_exclude_count=$(wc -l < "$JPG_EXCLUDE_FILE" | tr -d ' ')
    if [[ "$jpg_exclude_count" -gt 0 ]]; then
        log "  Skipping $jpg_exclude_count JPGs (matching raw exists)"
        COUNT_SKIPPED_JPG_DNG=$jpg_exclude_count
    fi

    # Sync to each drive
    for drive in "${drives[@]}"; do
        sync_to_drive "$drive"
    done

    # Summary
    log ""
    if [[ "$DRY_RUN" == true ]]; then
        log "${BOLD}Summary (dry run):${NC}"
    else
        log "${BOLD}Summary:${NC}"
    fi
    log "  Copied: $COUNT_COPIED files"
    log "  Already on backup: $COUNT_SKIPPED_EXISTS files"
    log "  Skipped (JPG with raw): $COUNT_SKIPPED_JPG_DNG files"
    log "  Sidecars/README updated: $COUNT_SIDECARS_UPDATED files"
    log "  Collisions moved: $COUNT_COLLISIONS files"
    log ""
    log "Log written to: $LOG_FILE"

    echo "$(date): backup-photos completed" >> "$LOG_FILE"
}

main "$@"
